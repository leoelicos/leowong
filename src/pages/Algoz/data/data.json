[
  {
    "name": "Max Consecutive Ones III",
    "link": "https://leetcode.com/problems/max-consecutive-ones-iii/",
    "solution": "var orangesRotting = function (mat) {\n  let q = []\n  let q2 = []\n  let bananas = 0\n  for (let i = 0; i < mat.length; i++) {\n    for (let j = 0; j < mat[0].length; j++) {\n      if (mat[i][j] === 0) mat[i][j] = ' '\n      else if (mat[i][j] === 1) {\n        mat[i][j] = 'x'\n        bananas++\n      } else q.push([i, j])\n    }\n  }\n  let count = 0\n\n  while (q.length) {\n    q2.length = 0\n    while (q.length > 0) {\n      let [i, j] = q.shift()\n      const dirs = [\n        [i - 1, j],\n        [i + 1, j],\n        [i, j - 1],\n        [i, j + 1]\n      ].filter(([y, x]) => y >= 0 && x >= 0 && y < mat.length && x < mat[0].length && mat[y][x] === 'x')\n      q2.push(...dirs)\n    }\n    q2.forEach(([y, x]) => {\n      if (mat[y][x] !== 2) {\n        bananas--\n        mat[y][x] = 2\n      }\n    })\n    q.length = 0\n    q.push(...q2)\n    if (q.length > 0) count++\n  }\n  return bananas > 0 ? -1 : count\n}"
  },
  {
    "name": "Capacity To Ship Packages Within D Days",
    "link": "https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/",
    "solution": "var shipWithinDays = function (weights, days) {\n  let maxWeight = 1\n  let totalWeight = 0\n\n  for (const w of weights) {\n    totalWeight += w\n    if (w > maxWeight) maxWeight = w\n  }\n\n  const possible = (capacity) => {\n    let weight = 0\n    let day = 1\n\n    for (const w of weights) {\n      if (weight + w > capacity) {\n        weight = 0\n        day++\n        if (day > days) return false\n      }\n      weight += w\n    }\n    return true\n  }\n\n  let memo = {}\n  let leftWeight = maxWeight\n  let rightWeight = totalWeight\n\n  memo[leftWeight] = possible(leftWeight)\n  if (memo[leftWeight] === true) return leftWeight\n  memo[rightWeight] = possible(rightWeight)\n\n  while (1) {\n    const midpoint = Math.floor((leftWeight + rightWeight) / 2)\n    const midpointIsPossible = possible(midpoint)\n    memo[midpoint] = midpointIsPossible\n\n    if (midpointIsPossible) {\n      if (memo[midpoint - 1] === false) return midpoint\n      else rightWeight = midpoint\n    } else {\n      if (memo[midpoint + 1] === true) return midpoint + 1\n      else leftWeight = midpoint\n    }\n  }\n}\n"
  },
  { "name": "Binary Tree Level Order Traversal", "link": "https://leetcode.com/problems/binary-tree-level-order-traversal/", "solution": "var levelOrder = function (root) {\n  if (!root) return []\n\n  const levels = [root]\n  let results = []\n  while (levels.length > 0) {\n    const t = [].concat(levels)\n    levels.length = 0\n\n    for (const node of t) {\n      if (node.left) levels.push(node.left)\n      if (node.right) levels.push(node.right)\n    }\n    if (t.length > 0) results.push(t.map((node) => node.val))\n  }\n  return results\n}\n" },
  { "name": "Construct Binary Tree from Preorder and Inorder Traversal", "link": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/", "solution": "var buildTree = function (preorder, inorder) {\n  let rootValue = 0\n  let rootLeft = null\n  let rootRight = null\n  if (preorder.length > 0 && inorder.length > 0) {\n    rootValue = preorder[0]\n    const split = inorder.indexOf(rootValue)\n    if (split !== 0) {\n      rootLeft = buildTree(preorder.slice(1, 1 + split), inorder.slice(0, split))\n    }\n    if (inorder.length - 1 > split) {\n      rootRight = buildTree(preorder.slice(1 + split, inorder.length), inorder.slice(split + 1, inorder.length))\n    }\n  }\n  return { val: rootValue, left: rootLeft, right: rootRight }\n}\n" },
  { "name": "Construct Binary Tree from Inorder and Postorder Traversal", "link": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/", "solution": "var buildTree = function (inorder, postorder) {\n  let rootValue = 0\n  let rootLeft = null\n  let rootRight = null\n  if (inorder.length > 0 && postorder.length > 0) {\n    rootValue = postorder[postorder.length - 1]\n    const split = inorder.indexOf(rootValue)\n    if (split !== 0) {\n      rootLeft = buildTree(inorder.slice(0, split), postorder.slice(0, split))\n    }\n    if (inorder.length - 1 > split) {\n      rootRight = buildTree(inorder.slice(split + 1, inorder.length), postorder.slice(split, -1))\n    }\n  }\n  return { val: rootValue, left: rootLeft, right: rootRight }\n}\n" },
  { "name": "Container With Most Water", "link": "https://leetcode.com/problems/container-with-most-water/", "solution": "var maxArea = function (height) {\n  let maxArea = 0\n\n  let left = 0\n  let right = height.length - 1\n\n  while (left < right) {\n    let area = Math.min(height[left], height[right]) * (right - left)\n    maxArea = Math.max(area, maxArea)\n    if (height[left] < height[right]) left++\n    else right--\n  }\n\n  return maxArea\n}\n" },
  { "name": "Populating Next Right Pointers in Each Node", "link": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/", "solution": "var connect = function (root) {\n  if (!root) return null\n  let nodes = [root]\n  while (nodes.length > 0) {\n    let temp = [...nodes]\n    for (let i = 0; i < temp.length; i++) {\n      if (i === temp.length - 1) temp[i].next = null\n      else temp[i].next = temp[i + 1]\n    }\n    nodes.length = 0\n    temp.forEach((node) => {\n      if (node.left) nodes.push(node.left)\n      if (node.right) nodes.push(node.right)\n    })\n  }\n  return root\n}\n" },
  { "name": "Populating Next Right Pointers in Each Node II", "link": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/", "solution": "var connect = function (root) {\n  if (!root) return root\n  link([root])\n  return root\n}\nvar link = function (parents) {\n  if (!parents) return\n  let children = []\n  for (let i = 0; i < parents.length; i++) {\n    let root = parents[i]\n    let l = parents[i].left\n    let r = parents[i].right\n    if (i < parents.length - 1) {\n      root.next = parents[i + 1]\n    }\n    if (l !== null) {\n      children.push(l)\n    }\n    if (r !== null) {\n      children.push(r)\n    }\n  }\n  if (children.length !== 0) link(children)\n}\n" },
  { "name": "Longest Consecutive Sequence", "link": "https://leetcode.com/problems/longest-consecutive-sequence/", "solution": "var longestConsecutive = function (nums) {\n  if (!nums.length) return 0\n  let max = 1\n  const memo = {}\n  for (v of nums) {\n    let start = v\n    let end = v\n    if (!!memo[v - 1]) start = memo[v - 1].head\n    if (!!memo[v + 1]) end = memo[v + 1].tail\n    max = Math.max(end - start + 1, max)\n    for (let i = start; i <= end; i++) memo[i] = { head: start, tail: end }\n  }\n  return max\n}\n" },
  { "name": "Linked List Cycle II", "link": "https://leetcode.com/problems/linked-list-cycle-ii/", "solution": "var detectCycle = function (head) {\n  let h = head\n  const memo = []\n  while (!memo.includes(h) && h !== null) {\n    memo.push(h)\n    h = h.next\n  }\n  if (h === null) return null\n  else if (memo.includes(h)) return h\n}\n" },
  { "name": "Two Sum II - Input Array Is Sorted", "link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/", "solution": "var twoSum = function (numbers, target) {\n  let memo = numbers.reduce((a, b) => {\n    a[b] = (a[b] || 0) + 1\n    if (a[b] > 2) a[b] = 2\n    return a\n  }, {})\n  for (let k in memo) {\n    k = parseInt(k)\n    if (memo[target - k]) {\n      if (target - k === k) return [numbers.indexOf(k) + 1, numbers.lastIndexOf(k) + 1]\n      return [numbers.indexOf(k) + 1, numbers.indexOf(target - k) + 1].sort((a, b) => a - b)\n    }\n  }\n}\n" },
  { "name": "Rotate Array", "link": "https://leetcode.com/problems/rotate-array/", "solution": "var rotate = function (nums, k) {\n  let l = nums.length\n  for (let i = 0; i < l; i++) nums[i + l] = nums[i - k < 0 ? (200 * l + i - k) % l : i - k]\n  for (let i = 0; i < l; i++) nums[i] = nums[i + l]\n  nums.length = l\n}\n" },
  { "name": "Remove Nth Node From End of List", "link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/", "solution": "var removeNthFromEnd = function (head, n) {\n  if (!head.next) return null\n  let fast = head\n  while (n-- > 0) {\n    fast = fast.next\n  }\n  if (!fast) return head.next\n  let slow = head\n  while (fast && fast.next) {\n    slow = slow.next\n    fast = fast.next\n  }\n  slow.next = slow.next.next\n  return head\n}\n" },
  { "name": "Add Two Numbers", "link": "https://leetcode.com/problems/add-two-numbers/", "solution": "var addTwoNumbers = function (l1, l2) {\n  let carryover = 0\n  let r = []\n  while (l1 || l2 || carryover > 0) {\n    let sum = carryover + (l1?.val || 0) + (l2?.val || 0)\n    carryover = sum >= 10 ? 1 : 0\n    sum %= 10\n    r.push(sum)\n    if (l1) l1 = l1.next\n    if (l2) l2 = l2.next\n  }\n  let next = null\n  let l\n  for (let i = r.length - 1; i >= 0; i--) {\n    l = new ListNode(r[i], next)\n    next = l\n  }\n  return l\n}\n" },
  { "name": "Number of Islands", "link": "https://leetcode.com/problems/number-of-islands/", "solution": "var numIslands = function (grid) {\n  let count = 0\n  let m = grid.length\n  let n = grid[0].length\n\n  const deleteIslands = (i, j) => {\n    grid[i][j] = '0'\n\n    if (i - 1 >= 0 && grid[i - 1][j] === '1') deleteIslands(i - 1, j)\n    if (i + 1 < m && grid[i + 1][j] === '1') deleteIslands(i + 1, j)\n    if (j - 1 >= 0 && grid[i][j - 1] === '1') deleteIslands(i, j - 1)\n    if (j + 1 < n && grid[i][j + 1] === '1') deleteIslands(i, j + 1)\n  }\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] === '1') {\n        count++\n        deleteIslands(i, j)\n      }\n    }\n  }\n\n  return count\n}\n" },
  { "name": "Kth Largest Element in an Array", "link": "https://leetcode.com/problems/kth-largest-element-in-an-array/", "solution": "var findKthLargest = function (nums, k) {\n  const memo = {}\n  for (const num of nums) memo[num] = (memo[num] || 0) + 1\n  let values = Object.keys(memo).sort((a, b) => b - a)\n  let runningSum = 0\n  for (let i = 0; i < values.length; i++) {\n    runningSum += memo[values[i]]\n    if (runningSum >= k) return values[i]\n  }\n  return new Error('unfound')\n}\n" },
  { "name": "Generate Parentheses", "link": "https://leetcode.com/problems/generate-parentheses/", "solution": "var generateParenthesis = function (n) {\n  let stack = [{ s: '(', l: n - 1, r: n }] // array of {combinations, l, r}\n  let flag = true\n\n  while (flag) {\n    let size = stack.length\n    for (let i = 0; i < size; i++) {\n      const { s, l, r } = stack.shift()\n      if (l === 0 && r === 0) {\n        stack.push(s)\n        flag = false\n      }\n      if (l > 0) {\n        stack.push({ s: s + '(', l: l - 1, r })\n        if (r > l) stack.push({ s: s + ')', l, r: r - 1 })\n      } else if (r > 0) {\n        stack.push({ s: s + ')', l, r: r - 1 })\n      }\n    }\n  }\n  return stack\n}\n" },
  { "name": "Find Players With Zero or One Losses", "link": "https://leetcode.com/problems/find-players-with-zero-or-one-losses/", "solution": "var findWinners = function (matches) {\n  let memo = {}\n  for (const [winner, loser] of matches) {\n    memo[loser] = (memo[loser] || 0) + 1\n    memo[winner] = memo[winner] || 0\n  }\n  const noLosses = []\n  const oneLoss = []\n  for (const i in memo) {\n    if (memo[i] === 0) noLosses.push(i)\n    else if (memo[i] === 1) oneLoss.push(i)\n  }\n  return [noLosses, oneLoss]\n}\n" },
  { "name": "Kth Smallest Element in a BST", "link": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/", "solution": "var kthSmallest = function (root, k) {\n  let nums = []\n\n  var dfs = function (node) {\n    if (!node) return\n    nums.push(node.val)\n    if (node.left) dfs(node.left)\n    if (node.right) dfs(node.right)\n  }\n\n  dfs(root)\n\n  nums = nums.sort((a, b) => a - b)\n\n  return nums[k - 1]\n}\n" },
  { "name": "Lowest Common Ancestor of a Binary Search Tree", "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/", "solution": "var lowestCommonAncestor = function (root, p, q) {\n  if (root.val > p.val && root.val > q.val) {\n    return lowestCommonAncestor(root.left, p, q)\n  } else if (root.val < p.val && root.val < q.val) {\n    return lowestCommonAncestor(root.right, p, q)\n  } else {\n    return root\n  }\n}\n" },
  { "name": "Lowest Common Ancestor of a Binary Tree", "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/", "solution": "var lowestCommonAncestor = function (root, p, q) {\n  if (!root) return null\n\n  let path = [root]\n  let node = root\n  let memo = {}\n\n  const dfs = () => {\n    if (node.left) dfs(node.left)\n    if (node.right) dfs(node.right)\n  }\n\n  dfs(root)\n}\n" },
  { "name": "Delete Node in a Linked List", "link": "https://leetcode.com/problems/delete-node-in-a-linked-list/", "solution": "var deleteNode = function (node) {\n  let prev = node\n  let curr = node.next\n\n  while (curr) {\n    prev.val = curr.val\n    if (!curr.next) prev.next = null\n    else prev = curr\n    curr = curr.next\n  }\n}\n" },
  { "name": "Product of Array Except Self", "link": "https://leetcode.com/problems/product-of-array-except-self/", "solution": "var productExceptSelf = function (nums) {\n  const product = nums.reduce((a, b) => a * b, 1)\n  const r = nums.map((v, i) =>\n    v === 0\n      ? nums\n          .slice(0, i)\n          .concat(nums.slice(i + 1))\n          .reduce((a, b) => a * b, 1)\n      : product * Math.pow(v, -1)\n  )\n  return r\n}\n" },
  { "name": "Perfect Squares", "link": "https://leetcode.com/problems/perfect-squares/", "solution": "var numSquares = function (n) {\n  const memo = { 0: 0, 1: 1 }\n  function dfs(n) {\n    if (n in memo) return (value = memo[n])\n    const stack = []\n    const bound = Math.floor(Math.pow(n, 0.5))\n    for (let i = 1; i <= bound; i++) stack.push(n - i ** 2)\n    value = Math.min(...stack.map((n) => 1 + dfs(n)))\n    memo[n] = value\n    return value\n  }\n  dfs(n)\n  return memo[n]\n}" },
  { "name": "Find the Duplicate Number", "link": "https://leetcode.com/problems/find-the-duplicate-number/", "solution": "var findDuplicate = function (nums) {\n  const memo = {}\n  for (let i = 0; i < nums.length; i++) {\n    if (memo[nums[i]] !== undefined) return nums[i]\n    memo[nums[i]] = 1\n  }\n}\n" },
  { "name": "Longest Substring Without Repeating Characters", "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/", "solution": "const lengthOfLongestSubstring = (s) =>\n  s.split('').reduce((a, _, i) => {\n    let uniques = []\n    let j = 0\n    while (!uniques.includes(s[i + j])) {\n      uniques.push(s[i + j])\n      j++\n    }\n    return j > a.length ? uniques.join('') : a\n  }, '').length\n" },
  { "name": "Odd Even Linked List", "link": "https://leetcode.com/problems/odd-even-linked-list/", "solution": "var oddEvenList = function (head) {\n  if (!head) return null\n  else if (!head.next) return head\n\n  const oddHead = new ListNode()\n  const evenHead = new ListNode()\n  let odd = oddHead\n  let even = evenHead\n\n  let n = 0\n  while (head) {\n    n++\n    if (n % 2 === 1) {\n      odd.next = head\n      odd = odd.next\n    } else {\n      even.next = head\n      even = even.next\n    }\n    head = head.next\n  }\n  even.next = null\n  odd.next = evenHead.next\n  return oddHead.next\n}\n" },
  { "name": "Valid Sudoku", "link": "https://leetcode.com/problems/valid-sudoku/", "solution": "var isValidSudoku = function (board) {\n  const rows = board\n  const columns = board.map((_, i) => board.map((r) => r[i]))\n  const squares = board.map((_, i) => {\n    const r = Math.floor(i / 3) * 3\n    const c = 3 * (i % 3)\n\n    return [board[r][c], board[r][c + 1], board[r][c + 2], board[r + 1][c], board[r + 1][c + 1], board[r + 1][c + 2], board[r + 2][c], board[r + 2][c + 1], board[r + 2][c + 2]]\n  })\n  const all = rows.concat(columns, squares)\n  const check = (r) => r.every((v, i) => v === '.' || r.indexOf(v) === i)\n\n  return all.every(check)\n}\n" },
  { "name": "Shuffle an Array", "link": "https://leetcode.com/problems/shuffle-an-array/", "solution": " class Solution {\n  constructor(nums) {\n    this.originalNums = nums\n    this.nums = nums\n  }\n}\n\nSolution.prototype.reset = function () {\n  this.nums = this.originalNums\n  return this.nums\n}\n\nSolution.prototype.shuffle = function () {\n  const stack = this.nums.slice()\n  const permutation = []\n  while (stack.length) {\n    var randomIndex = Math.floor(Math.random() * stack.length)\n    var element = stack.splice(randomIndex, 1)\n    permutation.push(element[0])\n  }\n  this.nums = permutation\n  return this.nums\n}\n" },
  { "name": "4Sum II", "link": "https://leetcode.com/problems/4sum-ii/", "solution": "var fourSumCount = function (nums1, nums2, nums3, nums4) {\n  let tuples = 0\n  const memo1 = {}\n  for (const i of nums1) for (const j of nums2) memo1[i + j] = (memo1[i + j] || 0) + 1\n  for (const k of nums3) for (const l of nums4) if (memo1.hasOwnProperty(-k - l)) tuples += memo1[-k - l]\n  return tuples\n}\n" },
  { "name": "Permutations", "link": "https://leetcode.com/problems/permutations/", "solution": "function permute(input) {\n  let permArr = []\n  let usedChars = []\n  return x(input, permArr, usedChars)\n}\nfunction x(input, permArr, usedChars) {\n  var i, ch\n  for (i = 0; i < input.length; i++) {\n    ch = input.splice(i, 1)[0]\n    usedChars.push(ch)\n    if (input.length === 0) permArr.push(usedChars.slice())\n    x(input, permArr, usedChars)\n    input.splice(i, 0, ch)\n    usedChars.pop()\n  }\n  return permArr\n}\n" },
  { "name": "Rotate Image", "link": "https://leetcode.com/problems/rotate-image/", "solution": "var rotate = function (matrix) {\n  let m = matrix.length\n  let coords = []\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < m; j++) {\n      coords.push({ i, j, val: matrix[m - 1 - j][i] })\n    }\n  }\n  coords.forEach(({ i, j, val }) => {\n    matrix[i][j] = val\n  })\n}\n" },
  { "name": "Group Anagrams", "link": "https://leetcode.com/problems/group-anagrams/", "solution": "var groupAnagrams = function (strs) {\n  const memo = {}\n  for (const word of strs) {\n    let serial = word.split('').sort().join('')\n    memo[serial] = [word].concat(memo[serial] || [])\n  }\n  return Object.values(memo)\n}\n" },
  { "name": "Longest Palindromic Substring", "link": "https://leetcode.com/problems/longest-palindromic-substring/", "solution": "var longestPalindrome = function (s) {\n  if (s.length === 1) return s[0]\n\n  let stack = []\n  for (let i = 0; i < s.length; i++) {\n    let j\n    /* even locus */\n    if (s[i] === s[i + 1]) {\n      for (j = 0; i - j >= 0 && i + 1 + j < s.length && s[i - j] === s[i + 1 + j]; j++) {}\n      stack.push(s.slice(i - j + 1, i + 1 + j))\n    }\n    /* odd locus */\n    if (s[i - 1] === s[i + 1]) {\n      for (j = 0; i - 1 - j >= 0 && i + 1 + j < s.length && s[i - 1 - j] === s[i + 1 + j]; j++) {}\n      stack.push(s.slice(i - 1 - j + 1, i + 1 + j))\n    }\n  }\n  if (stack.length === 0) return s[0]\n  stack = stack.sort((a, b) => a.length - b.length)\n  return stack.pop()\n}\n" },
  { "name": "Maximum Subarray", "link": "https://leetcode.com/problems/maximum-subarray/", "solution": "var maxSubArray = function (nums) {\n  let sum = nums[0]\n  let max = nums[0]\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i]\n    sum = Math.max(sum, nums[i])\n    max = Math.max(max, sum)\n  }\n  return max\n}\n" },
  { "name": "01 Matrix", "link": "https://leetcode.com/problems/01-matrix/", "solution": "var updateMatrix = function (mat) {\n  let q = []\n  for (let i = 0; i < mat.length; i++) {\n    for (let j = 0; j < mat[0].length; j++) {\n      if (mat[i][j] === 1) mat[i][j] = Infinity\n      else q.push([i, j])\n    }\n  }\n  while (q.length > 0) {\n    let [i, j] = q.shift()\n    const dirs = [\n      [i - 1, j],\n      [i + 1, j],\n      [i, j - 1],\n      [i, j + 1]\n    ].filter(([y, x]) => y >= 0 && x >= 0 && y < mat.length && x < mat[0].length && mat[y][x] === Infinity)\n    dirs.forEach(([y, x]) => {\n      mat[y][x] = mat[i][j] + 1\n    })\n    q.push(...dirs)\n  }\n  return mat\n}\n" },
  {
    "name": "Number of Provinces",
    "link": "https://leetcode.com/problems/number-of-provinces/",
    "solution": "var findCircleNum = function (isConnected) {\n  const uf = new UnionFind(isConnected.length)\n\n  for (let i = 0; i < isConnected.length; i++) {\n    for (let j = 0; j < isConnected[i].length; j++) {\n      if (isConnected[i][j] === 1 && i <= j) {\n        uf.union(i, j)\n      }\n    }\n  }\n\n  for (let i = 0; i < isConnected.length; i++) uf.find(i)\n\n  return uf.provinces()\n}\n\nclass UnionFind {\n  constructor(size) {\n    this.root = []\n    this.rank = []\n    for (let i = 0; i < size; i++) {\n      this.root[i] = i\n      this.rank[i] = 1\n    }\n  }\n\n  find(x) {\n    if (x === this.root[x]) return x\n    let query = this.root[x]\n    return (this.root[x] = this.find(query))\n  }\n\n  union(x, y) {\n    let rootX = this.find(x)\n    let rootY = this.find(y)\n\n    if (rootX != rootY) {\n      if (this.rank[rootX] > this.rank[rootY]) {\n        this.root[rootY] = rootX\n      } else if (this.rank[rootX] < this.rank[rootY]) {\n        this.root[rootX] = rootY\n      } else {\n        this.root[rootY] = rootX\n        this.rank[rootX]++\n      }\n    }\n  }\n\n  connected(x, y) {\n    return this.find(x) === this.find(y)\n  }\n\n  provinces() {\n    return new Set(this.root).size\n  }\n}\n"
  },
  { "name": "Merge Intervals", "link": "https://leetcode.com/problems/merge-intervals/", "solution": "var merge = function (intervals) {\n  intervals = intervals.sort((a, b) => (a[0] >= b[0] ? 1 : -1))\n  let j = 0\n  let stack = [intervals[0]]\n  for (let i = 1; i < intervals.length; i++) {\n    while (i < intervals.length && stack[j][1] >= intervals[i][0]) {\n      stack[j][1] = Math.max(stack[j][1], intervals[i][1])\n      i++\n    }\n\n    if (i < intervals.length) stack.push(intervals[i])\n\n    j++\n  }\n  return stack\n}\n" },
  { "name": "Permutation in String", "link": "https://leetcode.com/problems/permutation-in-string/", "solution": "const isMemoEqual = (memo1, memo2) => {\n  for (let i in memo1) {\n    if (memo2[i] !== memo1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst checkInclusion = (s1, s2) => {\n  if (s1.length > s2.length) return false\n  const memo = {}\n  for (let i = 0; i < s1.length; i++) {\n    memo[s1[i]] = (memo[s1[i]] || 0) + 1\n  }\n\n  let memo2 = {}\n  let left = 0\n  let right = 0\n  while (right < s1.length - 1) {\n    if (!!memo[s2[right]]) memo2[s2[right]] = (memo2[s2[right]] || 0) + 1\n    right++\n  }\n  if (isMemoEqual(memo, memo2)) return true\n\n  while (right !== s2.length) {\n    if (!!memo[s2[right]]) memo2[s2[right]] = (memo2[s2[right]] || 0) + 1\n    if (isMemoEqual(memo, memo2)) return true\n    if (!!memo[s2[left]]) memo2[s2[left]] = memo2[s2[left]] - 1\n    left++\n    right++\n  }\n  return false\n}\n" },
  { "name": "Insert Interval", "link": "https://leetcode.com/problems/insert-interval/", "solution": "const find = ([a, b], [c, d]) => (a <= c && c <= b) || (c <= a && a <= d)\nconst union = ([a, b], [c, d]) => [Math.min(a, c), Math.max(b, d)]\nconst insert = (r, t) => {\n  const stack = []\n  for (const v of r) find(v, t) ? (t = union(v, t)) : stack.push(v)\n  return [...stack, t].sort((a, b) => a[0] - b[0])\n}\n" },
  { "name": "Zigzag Conversion", "link": "https://leetcode.com/problems/zigzag-conversion/", "solution": "var convert = function (s, numRows) {\n  const cycle = numRows + Math.max(0, numRows - 2)\n  const r = new Array(numRows).fill('')\n  for (let i = 0; i < s.length; i++) {\n    let positionInCycle = i % cycle\n    let level = positionInCycle < numRows ? positionInCycle : 2 * numRows - 2 - positionInCycle\n    r[level] += s[i]\n  }\n  return r.join('')\n}\n" },
  { "name": "Unique Paths", "link": "https://leetcode.com/problems/unique-paths/", "solution": "function uniquePaths(m, n) {\n  m--\n  n--\n\n  let fac = 1\n  let lower = m <= n ? m : n\n  let higher = m <= n ? n : m\n\n  let sum = m + n\n  let facLower = undefined\n  let facHigher = undefined\n  let facSum = undefined\n\n  if (lower === 0) return 1\n  else if (higher === 0) return 1\n\n  for (let i = 1; i <= sum; i++) {\n    fac *= i\n\n    if (i === lower) facLower = fac\n    if (i === higher) facHigher = fac\n    if (i === sum) facSum = fac\n  }\n  if (facLower === 0) facLower = 1\n  return facSum / (facLower * facHigher)\n}\n" },
  {
    "name": "Max Area of Island",
    "link": "https://leetcode.com/problems/max-area-of-island/",
    "solution": "const union = (sets, i, j) => {\n  if (sets.length === 0) {\n    sets.push([[i, j]])\n\n    return\n  }\n  const matches = []\n  for (let idx = sets.length - 1; idx >= 0; idx--) {\n    for (const [y, x] of sets[idx]) {\n      let condition1 = x === j && Math.abs(y - i) === 1\n      let condition2 = y === i && Math.abs(x - j) === 1\n\n      if (condition1 || condition2) {\n        matches.push(...sets[idx])\n        sets.splice(idx, 1)\n        break\n      }\n    }\n  }\n  if (!matches.length) {\n    sets.push([[i, j]])\n\n    return\n  }\n\n  sets.push([...matches, [i, j]])\n}\n\nvar maxAreaOfIsland = function (grid) {\n  let sets = []\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) union(sets, i, j)\n    }\n  }\n  if (!sets.length) return 0\n\n  const maxSet = Math.max(...sets.map((set) => set.length))\n\n  return maxSet\n}"
  },
  { "name": "Reverse Integer", "link": "https://leetcode.com/problems/reverse-integer/", "solution": "var reverse = function (x) {\n  const integer = parseInt((x * (x < 0 ? -1 : 1)).toString().split('').reverse().join(''))\n  let result = x < 0 ? -integer : integer\n  return result < -Math.pow(2, 31) || result > Math.pow(2, 31) - 1 ? 0 : result\n}\n" },
  { "name": "Set Matrix Zeroes", "link": "https://leetcode.com/problems/set-matrix-zeroes/", "solution": "var setZeroes = function (matrix) {\n  if (!matrix.length) return matrix\n  const memo = { markedRows: {}, markedColumns: {} }\n\n  matrix.forEach((row, i) => {\n    row.forEach((cell, j) => {\n      if (cell === 0) {\n        memo.markedRows[i] = true\n        memo.markedColumns[j] = true\n      }\n    })\n  })\n\n  for (let i = 0; i < matrix.length; i++) {\n    for (const j in memo.markedColumns) {\n      matrix[i][+j] = 0\n    }\n  }\n  for (let j = 0; j < matrix[0].length; j++) {\n    for (const i in memo.markedRows) {\n      matrix[+i][j] = 0\n    }\n  }\n}\n" },
  { "name": "Search a 2D Matrix", "link": "https://leetcode.com/problems/search-a-2d-matrix/", "solution": "var searchMatrix = function (matrix, target) {\n  /* edge case */ if (target < matrix[0][0]) return false\n  /* edge case */ else if (target > matrix[matrix.length - 1][matrix[0].length - 1]) return false\n  let l = 0\n  let r = matrix.length - 1\n  while (l < r) {\n    let mid = Math.floor((l + r) / 2)\n    matrix[mid][matrix[mid].length - 1] >= target ? (r = mid) : (l = mid + 1)\n  }\n  let left = 0\n  let right = matrix[l].length - 1\n  while (left < right) {\n    let mid = Math.floor((left + right) / 2)\n    matrix[l][mid] >= target ? (right = mid) : (left = mid + 1)\n  }\n  return matrix[l][left] === target\n}\n" },
  { "name": "Sort Colors", "link": "https://leetcode.com/problems/sort-colors/", "solution": "var sortColors = function (nums) {\n  const memo = nums.reduce((a, b) => {\n    a[b] = (a[b] || 0) + 1\n    return a\n  }, {})\n\n  let j = 0\n  for (let i in memo) {\n    while (memo[i] > 0) {\n      nums[j] = i\n      memo[i]--\n      j++\n    }\n  }\n}\n" },
  { "name": "Combinations", "link": "https://leetcode.com/problems/combinations/", "solution": "function k_combinations(set, k) {\n  var i, j, combs, head, tailcombs\n\n  if (k > set.length || k <= 0) {\n    return []\n  }\n\n  if (k == set.length) {\n    return [set]\n  }\n\n  if (k === 1) {\n    combs = []\n    for (i = 0; i < set.length; i++) {\n      combs.push([set[i]])\n    }\n    return combs\n  }\n\n  combs = []\n  for (i = 0; i < set.length - k + 1; i++) {\n    head = set.slice(i, i + 1)\n    tailcombs = k_combinations(set.slice(i + 1), k - 1)\n    for (j = 0; j < tailcombs.length; j++) {\n      combs.push(head.concat(tailcombs[j]))\n    }\n  }\n  return combs\n}\n\nfunction combine(n, k) {\n  let array = []\n  for (let i = 1; i <= n; i++) array.push(i)\n  return k_combinations(array, k)\n}\n" },
  { "name": "Subsets", "link": "https://leetcode.com/problems/subsets/", "solution": "function k_combinations(set, k) {\n  var i, j, combs, head, tailcombs\n\n  if (k > set.length || k <= 0) {\n    return []\n  }\n\n  if (k == set.length) {\n    return [set]\n  }\n\n  if (k == 1) {\n    combs = []\n    for (i = 0; i < set.length; i++) {\n      combs.push([set[i]])\n    }\n    return combs\n  }\n\n  combs = []\n  for (i = 0; i < set.length - k + 1; i++) {\n    head = set.slice(i, i + 1)\n    tailcombs = k_combinations(set.slice(i + 1), k - 1)\n    for (j = 0; j < tailcombs.length; j++) {\n      combs.push(head.concat(tailcombs[j]))\n    }\n  }\n  return combs\n}\n\nfunction subsets(set) {\n  var k, i, combs, k_combs\n  combs = [[]]\n\n  for (k = 1; k <= set.length; k++) {\n    k_combs = k_combinations(set, k)\n    for (i = 0; i < k_combs.length; i++) {\n      combs.push(k_combs[i])\n    }\n  }\n  return combs\n}\n" },
  { "name": "String to Integer (atoi)", "link": "https://leetcode.com/problems/string-to-integer-atoi/", "solution": "var myAtoi = function (s) {\n  let string = s.replace(/^ *([+-]?\\d+).*/g, '$1')\n\n  let result = +string\n\n  return Number.isNaN(result) ? 0 : result < -2147483648 ? -2147483648 : result > 2147483647 ? 2147483647 : result\n}\n" },
  {
    "name": "Fruit Into Baskets",
    "link": "https://leetcode.com/problems/fruit-into-baskets/",
    "solution": "var totalFruit = function (fruits) {\n  if (fruits.length <= 2) return fruits.length\n\n  let max = 0\n  let runningMax = 0\n  let memo1 = undefined\n  let memo2 = undefined\n  let memo1i = undefined\n  let memo2i = undefined\n\n  let i = 0\n\n  runningMax++\n  memo1 = fruits[0]\n  memo1i = 0\n  i++\n\n  while (fruits[i] === memo1 && i < fruits.length) {\n    runningMax++\n    i++\n  }\n  if (i === fruits.length) max = Math.max(max, runningMax)\n\n  memo2 = fruits[i]\n  memo2i = i\n  while (fruits[i] === memo2 && i < fruits.length) {\n    runningMax++\n    i++\n  }\n\n  if (i === fruits.length) max = Math.max(max, runningMax)\n\n  while (i < fruits.length) {\n    while ((fruits[i] === memo1 || fruits[i] === memo2) && i < fruits.length) {\n      if (fruits[i] !== fruits[i - 1]) {\n        if (fruits[i] === memo1) memo1i = i\n        else memo2i = i\n      }\n\n      runningMax++\n      i++\n    }\n\n    max = Math.max(max, runningMax)\n\n    if (i < fruits.length) {\n      if (fruits[i - 1] === memo2) {\n        // shorten runningMax to the length of the last sequence of the i-1 fruit\n        // add the current index to runningMax\n        runningMax = i - memo2i\n        runningMax++\n        memo1 = fruits[i]\n        memo1i = i\n      } else if (fruits[i - 1] === memo1) {\n        runningMax = i - memo1i\n        runningMax++\n        memo2 = fruits[i]\n        memo2i = i\n      }\n    }\n\n    i++\n  }\n  return max\n}\n"
  },
  {
    "name": "Rotting Oranges",
    "link": "https://leetcode.com/problems/rotting-oranges/",
    "solution": "var orangesRotting = function (mat) {\n  let q = []\n  let q2 = []\n  let bananas = 0\n  for (let i = 0; i < mat.length; i++) {\n    for (let j = 0; j < mat[0].length; j++) {\n      if (mat[i][j] === 0) mat[i][j] = ' '\n      else if (mat[i][j] === 1) {\n        mat[i][j] = 'x'\n        bananas++\n      } else q.push([i, j])\n    }\n  }\n  let count = 0\n\n  while (q.length) {\n    q2.length = 0\n    while (q.length > 0) {\n      let [i, j] = q.shift()\n      const dirs = [\n        [i - 1, j],\n        [i + 1, j],\n        [i, j - 1],\n        [i, j + 1]\n      ].filter(([y, x]) => y >= 0 && x >= 0 && y < mat.length && x < mat[0].length && mat[y][x] === 'x')\n      q2.push(...dirs)\n    }\n    q2.forEach(([y, x]) => {\n      if (mat[y][x] !== 2) {\n        bananas--\n        mat[y][x] = 2\n      }\n    })\n    q.length = 0\n    q.push(...q2)\n    if (q.length > 0) count++\n  }\n  return bananas > 0 ? -1 : count\n}\n"
  },
  {
    "name": "Game of Life",
    "link": "https://leetcode.com/problems/game-of-life/description/",
    "solution": "var gameOfLife = function (board) {\n  let m = board.length\n  let n = board[0].length\n  let prev2 = []\n  let prev1 = []\n  let curr = []\n  let i\n  for (i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      let tl = i - 1 >= 0 && j - 1 >= 0 && board[i - 1][j - 1] === 1 ? 1 : 0\n      let t = i - 1 >= 0 && board[i - 1][j] === 1 ? 1 : 0\n      let tr = i - 1 >= 0 && j + 1 < n && board[i - 1][j + 1] === 1 ? 1 : 0\n      let l = j - 1 >= 0 && board[i][j - 1] === 1 ? 1 : 0\n      let r = j + 1 < n && board[i][j + 1] === 1 ? 1 : 0\n      let bl = i + 1 < m && j - 1 >= 0 && board[i + 1][j - 1] === 1 ? 1 : 0\n      let b = i + 1 < m && board[i + 1][j] === 1 ? 1 : 0\n      let br = i + 1 < m && j + 1 < n && board[i + 1][j + 1] === 1 ? 1 : 0\n      let neighbours = tl + t + tr + l + r + bl + b + br\n\n      let alive = board[i][j] === 1\n      let nextState = board[i][j]\n      if (!alive && neighbours === 3) nextState = 1\n      else if (neighbours !== 2 && neighbours !== 3) nextState = 0\n      curr.push(nextState)\n    }\n\n    if (prev2.length > 0) board[i - 2] = prev2.slice()\n    prev2 = prev1.slice()\n    prev1 = curr.slice()\n    curr.length = 0\n  }\n  if (prev2.length > 0) board[i - 2] = prev2.slice()\n  if (prev1.length > 0) board[i - 1] = prev1.slice()\n}\n"
  }
]
